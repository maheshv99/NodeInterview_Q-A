<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Day1 Interview</title>
    <style>
      h3 {
        color: red;
      }
      hr {
        border-style: ridge;
        border-color: black;
        border-radius: 20%;
      }
    </style>
  </head>
  <body>
    <h1 style="text-align: center; background-color: black; color: white">
      Nodejs Interview Day1
    </h1>

    <hr />
    <h3>1) What is node.js ?</h3>
    <blockquote>
      <ul>
        <li>
          Node.js is an open source and cross-platform runtime environment for
          executing JavaScript code outside of a browser.
        </li>
        <br />
        <li>
          You need to remember that NodeJS is not a framework and it’s not a
          programming language. Most of the people are confused and understand
          it’s a framework or a programming language.
        </li>
        <br />
        <li>
          We often use Node.js for building back-end services like APIs like Web
          App or Mobile App. It’s used in production by large companies such as
          Paypal, Uber, Netflix, Walmart and so on.
        </li>
        <br />
        <li>
          Node.js is a platform for building the i/o applications which are
          server-side event-driven and made using JavaScript. It is used to
          build server-side, input-output, event-driven apps. It is built on
          Google’s V8 engine.
        </li>
      </ul>
    </blockquote>
    <hr />
    <h3>2) What is NPM ?</h3>
    <blockquote>
      <ul>
        <li>
          NPM stands for the node package manager, npm is used for node
          dependency management
        </li>
        <br />
        <li>
          Most of the time, we use npm as a server-side node dependency tool
        </li>
        <br />
        <li>
          NPM gets installed with NodeJs installation. NPM uses nested
          dependencies, so we can use different versions of any module in our
          code.
        </li>
        <br />
        <li>
          Nested dependencies mean that any dependency is again dependent on
          another dependency npm: It is a package manager for the JavaScript
          programming language.
        </li>
        <br />
        <li>
          It is the default package manager for the JavaScript runtime
          environment Node.js. Help to manage a project’s dependencies. npm is
          installed with Node automatically.
        </li>
        <br />
        <li>
          npm: NPM generates a ‘package-lock.json’ file. the package-lock will
          generate the same node_modules folder for different npm versions
        </li>
        <br />
      </ul>
    </blockquote>
    <hr />
    <h3>3) What are the modules in Node.js ?</h3>
    <blockquote>
      <ul>
        <li>
          In Node.js, Modules are the blocks of encapsulated code that
          communicate with an external application on the basis of their related
          functionality.
        </li>
        <br />
        <li>
          Modules can be a single file or a collection of multiples
          files/folders
        </li>
        <br />
        <li>
          The reason programmers are heavily reliant on modules is because of
          their re-usability as well as the ability to break down a complex
          piece of code into manageable chunks. Modules are of three types:
        </li>
        <br />
      </ul>

      <ol>
        <li>Core Modules/Internal modules</li>
        <br />
        <li>Local Modules/Custom modules</li>
        <br />
        <li>Third-party Modules</li>
        <br />
      </ol>
      <h4>Core Modules/Internal modules :</h4>
      <blockquote>
        Node.js has many built-in modules that are part of the platform and
        comes with Node.js installation. These modules can be loaded into the
        program by using the require function. The require() function will
        return a JavaScript type depending on what the particular module
        returns. ex:- http creates an HTTP server in Node.js.
      </blockquote>

      <h4>Local Modules/Custom modules :</h4>
      <blockquote>
        Unlike built-in and external modules, local modules are created locally
        in your Node.js application. Let’s create a simple calculating module
        that calculates various operations. Another file can use its exported
        functionality using the require() function
      </blockquote>

      <h4>Third-party Modules :</h4>
      <blockquote>
        Third-party modules are modules that are available online using the Node
        Package Manager(NPM). These modules can be installed in the project
        folder or globally. Some of the popular third-party modules are
        mongoose, express, angular, and react.
        <br /><br />
        <div>Example: npm install express</div>
      </blockquote>
    </blockquote>

    <hr />
    <h3>4) What is the purpose of the module.exports ?</h3>
    <blockquote>
      <ul>
        <li>
          Module.exports is the instruction that tells Node. js which bits of
          code (functions, objects, strings, etc.) to “export” from a given file
          so other files are allowed to access the exported code.
        </li>
        <br />
        <li>
          The module.exports is actually a property of the module object in
          node.js. module. Exports is the object that is returned to the
          require() call.
        </li>
        <br />
        <li>
          By module.exports, we can export functions, objects, and their
          references from one file and can use them in other files by importing
          them by require() method. easy to maintain and manage the code base in
          different modules
        </li>
        <br />
      </ul>
    </blockquote>

    <hr />
    <h3>5) Difference between default export and named export</h3>
    <blockquote>
      <ul>
        <li>
          Export objects, functions, variables from the module so they can be
          used by other programs with the help of the import statements.
        </li>
        <br />
        <li>There are two types of exports.</li>
        <br />
        <ol>
          <li>Named Exports</li>
          <li>Default Exports</li>
        </ol>
        <h4>Named Exports :</h4>
        <blockquote>
          <ul>
            <li>Named exports are useful to export several values.</li>
            <li>
              During the import, it is mandatory to use the same name of the
              corresponding object.
            </li>
            <li>
              Named exports allow us to share multiple objects, functions or
              variables from a single file and were introduced with the release
              of ES2015.
            </li>
            <li>
              Named exports are imported with curly braces in various files and
              must be imported using the name of the object, function or
              variable that was exported.
            </li>
          </ul>
          <h4>Examples :</h4>
          <blockquote>
            <pre>
// Exporting individual features:
 export var name1 = …, name2 = …, …, nameN; // also let, const <br>
// Export list :
export { name1, name2, …, nameN };<br>
//Exporting everything at once :
export { object, number, x, y, boolean, string }<br>
// Renaming exports:
export { variable1 as name1, variable2 as name2, …, nameN };<br>
// export features declared earlier:
export { myFunction, myVariable };
                </pre>
          </blockquote>
        </blockquote>

        <h4>Default Exports</h4>
        <blockquote>
          <ul>
            <li>
              Default exports are useful to export only a single object,
              function, variable. During the import, we can use any name to
              import.Exports without a default tag are Named exports. Exports
              with the default tag are Default exports.
            </li>
            <li>
              - Using Named and Default Exports at the same time: It is possible
              to use Named and Default exports in the same file. It means both
              will be imported in the same file. Example: javascript.
            </li>
            <h4>Examples :</h4>
            <blockquote>
              <pre>
                                function defau(req,res){
                                    res.send("default exports")
                                    }
                                    function named(req,res) {
                                    res.send('named exports')
                                    }
                                    module.exports = default;//default export
                                    module.exports = {named};//named export
                            </pre
              >
            </blockquote>
          </ul>
        </blockquote>
      </ul>
    </blockquote>

    <hr />
    <h3>6) How do you import any module in Node.js</h3>
    <blockquote>
      <ul>
        <li>Importing functions or modules enhances the reusability of code</li>
        <br />
        <li>
          : We need to import the module to use the functions defined in the
          imported module in another file. The result returned by require() is
          stored in a variable which is used to invoke the functions using the
          dot notation.
        </li>
      </ul>
      <h4>Example :</h4>
      <blockquote>const f = require('./func')</blockquote>
    </blockquote>

    <hr />
    <h3>7) What are the different types of HTTP requests?</h3>
    <blockquote>
      <ul>
        <li>
          HTTP (Hypertext Transfer Protocol) specifies a collection of request
          methods to specify what action is to be performed on a particular
          resource. The most commonly used HTTP request methods are GET, POST,
          PUT, PATCH, and DELETE. These are equivalent to the CRUD operations
          (create, read, update, and delete).
        </li>

        <h4>GET :</h4>
        <blockquote>
          GET request is used to read/retrieve data from a web server. GET
          returns an HTTP status code of 200 (OK) if the data is successfully
          retrieved from the server.
        </blockquote>

        <h4>POST :</h4>
        <blockquote>
          POST request is used to send data (file, form data, etc.) to the
          server. On successful creation, it returns an HTTP status code of 201
        </blockquote>

        <h4>PUT :</h4>
        <blockquote>
          A PUT request is used to modify the data on the server. It replaces
          the entire content at a particular location with data that is passed
          in the body payload. If there are no resources that match the request,
          it will generate one.
        </blockquote>

        <h4>PATCH :</h4>
        <blockquote>
          PATCH is similar to PUT request, but the only difference is, it
          modifies a part of the data. It will only replace the content that you
          want to update.
        </blockquote>

        <h4>DELETE :</h4>
        <blockquote>
          A DELETE request is used to delete the data on the server at a
          specified location.
        </blockquote>
      </ul>
    </blockquote>

    <hr />
    <h3>
      8) Explain the concept of middleware in Node.js., Create a middleware
      which will be applicable to all the routes
    </h3>
    <blockquote>
      <ul>
        <li>
          Express.js is a routing and Middleware framework for handling the
          different routing of the webpage and it works between the request and
          response cycle.
        </li>
        <br />
        <li>
          Middleware gets executed after the server receives the request and
          before the controller actions send the response.
        </li>
        <br />
        <li>
          Middleware has the access to the request object, responses object, and
          next, it can process the request before the server send a response. An
          Express-based application is a series of middleware function calls.
        </li>
        <br />
        <li>
          Middleware Chaining: Middleware can be chained from one to another,
          Hence creating a chain of functions that are executed in order. The
          last function sends the response back to the browser. So, before
          sending the response back to the browser the different middleware
          processes the request.
        </li>
        <br />
        <li>
          The next() function in the express is responsible for calling the next
          middleware function if there is one.
        </li>
        <br />
        <h4>
          Create a middleware which will be applicable to all the routes :
        </h4>
        <blockquote>
          <pre>
                const express=require("express");
                const app =express();
                const middleWare1=(req,res,next)=>{
                    console.log("This is First Middle ware It is applicable for all Routes");
                    next();
                }
                app.use(middleWare1);
                
                app.get("/",(req,res)=>{
                    res.send("Applying the middle Ware");
                })
                app.get("/about",(req,res)=>{
                    console.log("Applying the Middle Ware");
                })
                app.listen(5000,()=>{
                    console.log("Server is running on the 5000 port");
                })
            </pre
          >
        </blockquote>
      </ul>
    </blockquote>
    <hr />
    <div style="text-align: center">💥💥💥💥💥💥🥈</div>
    <hr />
  </body>
</html>
